# restful-api-server

## 概要

Go の学習のため、高機能な RESTful API サーバーを作成する。

要件は Gemini を使用して生成した。
なお、このリポジトリはあくまで学習目的であるため、AI による支援は基本的にコードの生成ではなく、記述したコードに対する評価に使用する。

起動は `go run cmd/main.go --config=config/local.tml` とする。

## 学習メモ

- github.com/spf13/viper を使用したことがなかったため使用した。
- gin などのフレームワークは今後使用するかもしれないが、まずは net/http パッケージでサーバーを構築する。

## 要件

### アプリケーションの概要とドメインの決定

コンセプト: シンプルな「プロダクトカタログ＆ユーザー管理 API」とします。

主要エンティティ:

- User: ユーザー情報（ID, ユーザー名, メールアドレス, パスワードハッシュ, 作成日時, 更新日時など）
- Product: 商品情報（ID, 商品名, 説明, 価格, 在庫数, カテゴリ ID, 作成日時, 更新日時など）
- Category: カテゴリ情報（ID, カテゴリ名, 作成日時, 更新日時など）
- 役割: ユーザーと管理者の 2 種類の役割を想定します。（必須ではありませんが、認証・認可の学習に役立ちます）

### データベース連携

- RDB の採用: PostgreSQL を採用します。Docker などを使用してローカル環境に構築します。
- DB アクセス方法: database/sql パッケージを中心に利用します。ORM (GORM や Ent) は、初期段階では避け、Go 標準ライブラリでの DB 操作の理解を深めることを優先します。ただし、学習が進んだ段階で ORM への置き換えを検討するのも良いでしょう。
- コネクションプール: database/sql のコネクションプール設定（MaxOpenConns, MaxIdleConns, ConnMaxLifetime など）を適切に行います。
- マイグレーションツール: migrate (github.com/golang-migrate/migrate) などのツールを使用して、データベーススキーマのバージョン管理と適用を行います。初期スキーマ定義と、後続の変更をマイグレーションファイルとして管理します。
- トランザクション処理: 複数の DB 操作をアトミックに行う必要がある箇所（例：商品購入処理、在庫更新と注文作成など、今回のシンプル構成では不要かもしれませんが、将来的な拡張を考慮）では、トランザクションを適切に利用します。

### ユーザー認証機能

- 方式: JWT (JSON Web Tokens) を使用したステートレス認証を実装します。
- エンドポイント:
  - POST /signup: 新規ユーザー登録。ユーザー名、メールアドレス、パスワードを受け付けます。パスワードはハッシュ化して保存します（bcrypt などを利用）。
  - POST /login: ログイン。ユーザー名（またはメールアドレス）とパスワードを受け付け、認証成功時に JWT トークンを発行して返却します。
  - GET /me (認証必須): 認証済みユーザー自身の情報を取得します。
- JWT の実装:
  - アクセストークンの生成と署名（HMAC-SHA256 などを利用）。
  - トークンの検証とパース。
  - トークンの有効期限設定と検証。
  - 必要であれば、リフレッシュトークン機構の検討（より高度な学習として）。

### CRUD 操作

- 対象エンティティ: User, Product, Category
- エンドポイント例:
  - GET /products: 全商品リスト取得（ページネーション、ソート、フィルタリング機能も考慮すると高度）。
  - POST /products (認証・管理者権限など): 新規商品作成。
  - GET /products/{id}: 特定商品詳細取得。
  - PUT /products/{id} (認証・管理者権限など): 特定商品更新。
  - DELETE /products/{id} (認証・管理者権限など): 特定商品削除。
  - GET /categories: 全カテゴリリスト取得。
  - POST /categories (認証・管理者権限など): 新規カテゴリ作成。
  - PUT /categories/{id} (認証・管理者権限など): 特定カテゴリ更新。
  - DELETE /categories/{id} (認証・管理者権限など): 特定カテゴリ削除。
  - GET /users/{id} (認証・管理者権限など): 特定ユーザー情報取得。
  - PUT /users/{id} (認証・管理者権限など): 特定ユーザー情報更新。
  - DELETE /users/{id} (認証・管理者権限など): 特定ユーザー削除。
- レスポンス形式: 標準的な JSON フォーマットで返却します。リスト取得時は配列、詳細取得時はオブジェクトとなります。

### 入力値のバリデーション

- ライブラリ: go-playground/validator などのバリデーションライブラリを使用します。
- 対象: POST および PUT リクエストの JSON リクエストボディ。
- バリデーションルール例: 必須フィールド、最小/最大文字数、メールアドレス形式、数値の範囲、カスタムバリデーション（例: ユーザー名の一意性チェックはビジネスロジック層で行うなど、責務の分離も意識）。
- バリデーションエラー: バリデーションに失敗した場合、適切な HTTP ステータスコード（例: 400 Bad Request）と、エラー内容を詳細に含む JSON レスポンスを返却します。

### 適切なエラーレスポンスの設計（エラーハンドリングの実践）

- 標準エラーフォーマット: 一貫性のある JSON エラーレスポンスフォーマットを定義します。例:

```JSON
{
  "error": {
    "code": "specific_error_code", // オプションだが、クライアント側でエラーの種類を特定しやすい
    "message": "Descriptive error message.",
    "details": [] // バリデーションエラーなどの詳細情報
  }
}
```

- カスタムエラー型: アプリケーション固有のエラー（例: ErrNotFound, ErrAlreadyExists, ErrUnauthorized, ErrValidationFailed など）をカスタム型として定義し、エラー発生箇所で適切なエラーをラップまたは生成します。
- エラーマッピング: 発生したエラー型や原因に応じて、適切な HTTP ステータスコード（400, 401, 403, 404, 409, 500 など）と、前述の標準エラーフォーマットにマッピングする処理を共通化します。
- 予期しないエラー: panic を適切にリカバリーし、内部サーバーエラー（500 Internal Server Error）として処理するミドルウェアを実装します。スタックトレースはログに出力し、クライアントには返却しません。

### Context の活用

- リクエスト ID の伝播:
  - 最初のリクエスト受信時に一意のリクエスト ID（UUID など）を生成します。
  - 生成したリクエスト ID を context.Context に格納します。
  - ログ出力、エラーハンドリング、DB 操作など、後続の処理で Context を通じてこのリクエスト ID を参照し、ログに含めることでリクエストのトレースを容易にします。
  - レスポンスヘッダーにもリクエスト ID を含めると、クライアント側での追跡に役立ちます (X-Request-ID など)。
- タイムアウト設定:
  - ミドルウェアとして、全てのリクエストに対してデフォルトの処理タイムアウトを設定します (context.WithTimeout)。
  - 特定の処理がタイムアウトした際に、Context がキャンセルされることを確認し、そのシグナルを適切にハンドリング（例：DB クエリのキャンセルなど）します。
- ユーザー情報の Context への格納:
  - 認証ミドルウェアでトークン検証に成功した後、認証済みユーザーの ID や簡単な情報（ユーザー名、役割など）を Context に格納します。
  - ハンドラやサービス層で、Context からこの情報を取得し、認可判断やユーザー固有のデータ処理に使用します。

### ミドルウェアの実装

- 機能別ミドルウェア:
  - ロギングミドルウェア: 前述のリクエスト ID を含め、リクエストの開始、終了、処理時間、HTTP ステータスコードなどを構造化ログ形式（Zerolog や Zap など）で出力します。
  - 認証ミドルウェア: JWT トークンの検証を行い、有効なトークンであれば Context にユーザー情報を追加します。無効な場合は 401 Unauthorized エラーを返却します。
  - 認可ミドルウェア: Context からユーザー情報を取得し、アクセスしようとしているリソースや操作に対する権限があるかを確認します。権限がない場合は 403 Forbidden エラーを返却します。
  - ヘッダー設定ミドルウェア: レスポンスの Content-Type ヘッダーを application/json に設定するなど、共通ヘッダーを設定します。
  - リカバリーミドルウェア: panic を捕捉し、安全に 500 Internal Server Error として処理します。
- ミドルウェアチェーン: 各ミドルウェアを適切にチェーンして適用します。

### 適切にパッケージ分割されたプロジェクト構造

- 標準的な構造: 以下のディレクトリ構造を参考に、責務ごとにパッケージを分割します。

```
restful-api-server/
├── cmd/ # アプリケーションのエントリーポイント
│ └── api/ # API サーバーの起動コード (main.go など)
├── internal/ # 外部に公開しない内部実装
│ ├── api/ # HTTP ハンドラ定義
│ │ └── handler/ # ハンドラの実装
│ ├── config/ # 設定読み込み処理
│ ├── database/ # DB 接続、マイグレーション実行など
│ ├── middleware/ # 各種ミドルウェアの実装
│ ├── models/ # エンティティ構造体、DB スキーマ定義
│ ├── repository/ # データベースアクセス層 (DB との I/O のみ)
│ ├── service/ # ビジネスロジック層 (サービス間連携、Repository の呼び出しなど)
│ └── utils/ # 共通ユーティリティ関数
├── pkg/ # 外部に公開しても良いライブラリコード (今回はあまり使わないかも)
├── migrations/ # DB マイグレーションファイル
├── tests/ # 各種テストコード (後述)
├── .env # 環境変数ファイル (設定用)
└── go.mod # Go Modules ファイル
```

- 責務の分離: 各パッケージが単一の明確な責務を持つように設計します。
  - ハンドラ：リクエストの受付、Context からの情報取得、リクエストボディのデコードとバリデーション、サービス呼び出し、レスポンスのエンコードと返却 のみ を行います。ビジネスロジックは持ちません。
  - サービス：ビジネスロジックを実装します。Repository や他のサービスを呼び出します。
  - リポジトリ：データベースとの直接的なやり取り（SQL 実行） のみ を行います。ビジネスロジックやバリデーションは持ちません。
- インターフェースの活用: パッケージ間の依存関係を減らし、テスト容易性を高めるために、Service や Repository などのコンポーネントはインターフェースとして定義し、実装はそのインターフェースを満たすようにします。

### テストの記述

- 単体テスト:
  - 対象: service パッケージ、repository パッケージ（DB アクセス部分はモック化）、utils パッケージなどの、ビジネスロジックやコア機能を持つコンポーネント。
  - 目的: 各関数やメソッドが期待通りに動作するかを確認。
  - 実装: Go の標準 testing パッケージを使用。Repository のテストでは DB をモック化、Service のテストでは Repository のインターフェースをモック化（gomock などのライブラリ利用も検討）。
  - カバレッジ: 主要なロジックに対するテストカバレッジを意識します。
- 結合テスト（API エンドポイントに対するテスト）:
  - 対象: HTTP ハンドラからサービス、リポジトリ、データベースまでを含めた、API エンドポイント全体。
  - 目的: 複数のコンポーネント連携を含めた、エンドツーエンドのフローが正しく動作するかを確認。
  - 実装: net/http/httptest パッケージを使用して、実際に HTTP サーバーを起動せずにハンドラやルーターをテストします。
- テスト用データベース: クリーンな状態のテスト用 PostgreSQL データベースを準備し、テストケースごとにデータを投入/クリアします。Docker を使用すると便利です。
- テストケース: 各 API エンドポイントに対して、正常系、異常系（バリデーションエラー、認証失敗、存在しないリソース、権限不足など）のテストケースを記述します。HTTP ステータスコード、レスポンスボディの内容などを検証します。

### 設定管理

- データベース接続情報、JWT のシークレット、Listen ポートなどの設定は、ハードコードせず、環境変数から読み込むようにします。
- github.com/spf13/viper などのライブラリを利用すると、環境変数、設定ファイル、コマンドライン引数などからの設定読み込みを柔軟に行えます。

### 学習のポイントとして意識すべきこと

- エラーハンドリング: Go のエラーハンドリング哲学 (error インターフェース、エラーラッピング fmt.Errorf や xerrors) を理解し、実践します。
- 並行処理: HTTP サーバーはリクエストごとにゴルーチンを生成します。Context によるキャンセルシグナルの伝播など、並行処理における安全性を意識します。DB コネクションプールも並行処理を考慮した設計です。
- インターフェース指向: コンポーネント間の依存を具体型ではなくインターフェースに対して行うことで、テスト容易性と柔軟性を高めます。
- Go Modules: 依存関係管理を適切に行います。
- ドキュメンテーション: コード内にコメントを書くこと、必要であれば API 仕様を OpenAPI などで定義することも検討します（今回は必須ではありませんが、実務では重要です）。
